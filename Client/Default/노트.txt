코딩하면서 생긴 의문점들을 모두 모아봤습니다.

[template]
1. template은 virtual 가상함수 불가능!

[상속]
1. 자식은 생성자에서 무조건 부모의 생성자를 호출해야함. 

[const]
1. 왜 포인터는 const면 대입이 안되는거지? 반환할 때는 주소가 const? 아님 값이 const?
2. 멤버 const는 해당 함수 안에서 해당 클래스의 멤버 모두 const화되어 변경할 수 없음을 의미함. 이거 사용하려고 노력중!

[효율성]
1. push_back과 emplace_back의 차이점은?
2. 구조체에서 padding이란?
3. 함수 포인터는? 효율성과 명확성?? 때문에 템플릿과 함수포인터 또는 함수 객체를 같이 쓴다~라는 글을 봤던 거 같은데 (inline도 연관 있었음)
4. 굳이 포인터 사용하는 이유: 1. 여러 개 접근할 때 하나 통일된 이름으로 접근 가능 2. 메모리 넘겨줄 때 주소/값 만을 넘겨줄 수 있음 3. 메모리에 빠르게 접근할 수 있음
= 이거는 굳이 동적할당을 쓰는 이유와 동일한가? 내 생각에 동적할당은 어디에서 선언했던 간에 상관없이 소멸되지 않고 사용하기 위함? (동적할당->힙 메모리에 적재->프로그램 종료 시 소멸?)

[운영체제]


[습득한 지식]
- char과 wchar_t를 구분해서 사용하는 이유는 UTF-8과 UTF-16의 차이인데, 메모리 절약도 있겠지만
일반적으로 윈도우에서는 wchar_t를 사용한다. 그러나 특정 라이브러리 <stdlib.h>, <io.h> <file.H>에서
char을 사용하기 때문에 char도 혼용해서 사용하곤 한다. (미정확)
- 객체 배열은 '선언'시 무조건 기본 생성자만 호출됨, '초기화'는 각 원소마다 생성자 호출에서 가능
- 동적 할당한 객체 배열 delete[] 하면 생성 순서의 역순으로 소멸자 호출되면서 메모리 반환함.
- delete로 메모리 반환 시 해당 포인터는 그대로 기존 주소를 가리키기 때문에 댕글링 포인터 예방을 위해 nullptr 대입할 것
- 객체 배열은 선언은 무조건 기본 생성자, 초기화는 각 원소별로 생성자 호출 가능(대신 개수만큼 다 명시적으로 작성)
- 프로그램이 종료되면 운영체제는 누수 메모리를 힙 메모리에 모두 돌려주긴 함.